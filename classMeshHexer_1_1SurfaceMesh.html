<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeshHexer: MeshHexer::SurfaceMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeshHexer<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Meshing tool for hexahedral meshes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classMeshHexer_1_1SurfaceMesh.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMeshHexer_1_1SurfaceMesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MeshHexer::SurfaceMesh Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>MeshHexer surface mesh class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="meshhexer_8hpp_source.html">meshhexer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a184af8509bea58ac7387e89eef7f2535" id="r_a184af8509bea58ac7387e89eef7f2535"><td class="memItemLeft" align="right" valign="top"><a id="a184af8509bea58ac7387e89eef7f2535" name="a184af8509bea58ac7387e89eef7f2535"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh</b> (std::unique_ptr&lt; SurfaceMeshImpl &gt; ptr)</td></tr>
<tr class="memdesc:a184af8509bea58ac7387e89eef7f2535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a184af8509bea58ac7387e89eef7f2535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48984cf698347a4a3ce3f9931a4fab8e" id="r_a48984cf698347a4a3ce3f9931a4fab8e"><td class="memItemLeft" align="right" valign="top"><a id="a48984cf698347a4a3ce3f9931a4fab8e" name="a48984cf698347a4a3ce3f9931a4fab8e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~SurfaceMesh</b> ()</td></tr>
<tr class="memdesc:a48984cf698347a4a3ce3f9931a4fab8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a48984cf698347a4a3ce3f9931a4fab8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882430402a5c48adb025d72af2759c8f" id="r_a882430402a5c48adb025d72af2759c8f"><td class="memItemLeft" align="right" valign="top"><a id="a882430402a5c48adb025d72af2759c8f" name="a882430402a5c48adb025d72af2759c8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh</b> (<a class="el" href="classMeshHexer_1_1SurfaceMesh.html">SurfaceMesh</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:a882430402a5c48adb025d72af2759c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructor. <br /></td></tr>
<tr class="separator:a882430402a5c48adb025d72af2759c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8c267bd0666ba4c4881d7eca5eb7d4" id="r_aca8c267bd0666ba4c4881d7eca5eb7d4"><td class="memItemLeft" align="right" valign="top"><a id="aca8c267bd0666ba4c4881d7eca5eb7d4" name="aca8c267bd0666ba4c4881d7eca5eb7d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SurfaceMesh</b> (const <a class="el" href="classMeshHexer_1_1SurfaceMesh.html">SurfaceMesh</a> &amp;)=delete</td></tr>
<tr class="memdesc:aca8c267bd0666ba4c4881d7eca5eb7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructor. <br /></td></tr>
<tr class="separator:aca8c267bd0666ba4c4881d7eca5eb7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4bfda569a5eb6eb7f53d1ac8102cc5" id="r_a2f4bfda569a5eb6eb7f53d1ac8102cc5"><td class="memItemLeft" align="right" valign="top"><a id="a2f4bfda569a5eb6eb7f53d1ac8102cc5" name="a2f4bfda569a5eb6eb7f53d1ac8102cc5"></a>
<a class="el" href="classMeshHexer_1_1SurfaceMesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classMeshHexer_1_1SurfaceMesh.html">SurfaceMesh</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:a2f4bfda569a5eb6eb7f53d1ac8102cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign operator. <br /></td></tr>
<tr class="separator:a2f4bfda569a5eb6eb7f53d1ac8102cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8b61bd4ba7e5c691d488e2d05de19e" id="r_a8e8b61bd4ba7e5c691d488e2d05de19e"><td class="memItemLeft" align="right" valign="top"><a id="a8e8b61bd4ba7e5c691d488e2d05de19e" name="a8e8b61bd4ba7e5c691d488e2d05de19e"></a>
<a class="el" href="classMeshHexer_1_1SurfaceMesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classMeshHexer_1_1SurfaceMesh.html">SurfaceMesh</a> &amp;)=delete</td></tr>
<tr class="memdesc:a8e8b61bd4ba7e5c691d488e2d05de19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assign operator. <br /></td></tr>
<tr class="separator:a8e8b61bd4ba7e5c691d488e2d05de19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4854cbd791971299824961fbc9bf06" id="r_a6f4854cbd791971299824961fbc9bf06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMeshHexer_1_1BoundingBox.html">BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f4854cbd791971299824961fbc9bf06">bounding_box</a> () const</td></tr>
<tr class="memdesc:a6f4854cbd791971299824961fbc9bf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned bounding box of the mesh.  <br /></td></tr>
<tr class="separator:a6f4854cbd791971299824961fbc9bf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae394d799a1ba346a2feb37d430862397" id="r_ae394d799a1ba346a2feb37d430862397"><td class="memItemLeft" align="right" valign="top"><a id="ae394d799a1ba346a2feb37d430862397" name="ae394d799a1ba346a2feb37d430862397"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_vertices</b> () const</td></tr>
<tr class="memdesc:ae394d799a1ba346a2feb37d430862397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the surface mesh. <br /></td></tr>
<tr class="separator:ae394d799a1ba346a2feb37d430862397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875991bccc27a8470a410b068b25e5b4" id="r_a875991bccc27a8470a410b068b25e5b4"><td class="memItemLeft" align="right" valign="top"><a id="a875991bccc27a8470a410b068b25e5b4" name="a875991bccc27a8470a410b068b25e5b4"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_edges</b> () const</td></tr>
<tr class="memdesc:a875991bccc27a8470a410b068b25e5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges in the surface mesh. <br /></td></tr>
<tr class="separator:a875991bccc27a8470a410b068b25e5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6305da57a08a6554895f7b90404403d" id="r_ab6305da57a08a6554895f7b90404403d"><td class="memItemLeft" align="right" valign="top"><a id="ab6305da57a08a6554895f7b90404403d" name="ab6305da57a08a6554895f7b90404403d"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_faces</b> () const</td></tr>
<tr class="memdesc:ab6305da57a08a6554895f7b90404403d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of faces in the surface mesh. <br /></td></tr>
<tr class="separator:ab6305da57a08a6554895f7b90404403d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae397e5dcc71101bf3e659b137b402391" id="r_ae397e5dcc71101bf3e659b137b402391"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae397e5dcc71101bf3e659b137b402391">is_closed</a> () const</td></tr>
<tr class="memdesc:ae397e5dcc71101bf3e659b137b402391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface mesh describes a closed surface.  <br /></td></tr>
<tr class="separator:ae397e5dcc71101bf3e659b137b402391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c153e5973b1205608c450615894834" id="r_a79c153e5973b1205608c450615894834"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79c153e5973b1205608c450615894834">is_wound_consistently</a> () const</td></tr>
<tr class="memdesc:a79c153e5973b1205608c450615894834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the winding order of the faces of the surface mesh is consistent.  <br /></td></tr>
<tr class="separator:a79c153e5973b1205608c450615894834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f0e732d9e29c57f11de43f7aff1c7b" id="r_a70f0e732d9e29c57f11de43f7aff1c7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70f0e732d9e29c57f11de43f7aff1c7b">is_outward_oriented</a> () const</td></tr>
<tr class="memdesc:a70f0e732d9e29c57f11de43f7aff1c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface normals of all faces of the surface mesh point towards the unbounded side.  <br /></td></tr>
<tr class="separator:a70f0e732d9e29c57f11de43f7aff1c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419aa808cbfc07cb147f122aec2255e5" id="r_a419aa808cbfc07cb147f122aec2255e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a419aa808cbfc07cb147f122aec2255e5">minimal_aspect_ratio</a> () const</td></tr>
<tr class="memdesc:a419aa808cbfc07cb147f122aec2255e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest aspect ratio of any face of the surface mesh.  <br /></td></tr>
<tr class="separator:a419aa808cbfc07cb147f122aec2255e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef6379c61b78d97e3f9e9974ec6fa90" id="r_acef6379c61b78d97e3f9e9974ec6fa90"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acef6379c61b78d97e3f9e9974ec6fa90">maximal_aspect_ratio</a> () const</td></tr>
<tr class="memdesc:acef6379c61b78d97e3f9e9974ec6fa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the largest aspect ratio of any face of the surface mesh.  <br /></td></tr>
<tr class="separator:acef6379c61b78d97e3f9e9974ec6fa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6feaca6ee9fc384afe3a71d597580d38" id="r_a6feaca6ee9fc384afe3a71d597580d38"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structMeshHexer_1_1Gap.html">Gap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6feaca6ee9fc384afe3a71d597580d38">gaps</a> ()</td></tr>
<tr class="memdesc:a6feaca6ee9fc384afe3a71d597580d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <a class="el" href="structMeshHexer_1_1Gap.html" title="Possible interior diameter of a surface mesh.">Gap</a> candidates of the surface mesh.  <br /></td></tr>
<tr class="separator:a6feaca6ee9fc384afe3a71d597580d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21900d33c96ef8392057e91bb8bfae93" id="r_a21900d33c96ef8392057e91bb8bfae93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMeshHexer_1_1Gap.html">Gap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21900d33c96ef8392057e91bb8bfae93">min_gap</a> ()</td></tr>
<tr class="memdesc:a21900d33c96ef8392057e91bb8bfae93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest <a class="el" href="structMeshHexer_1_1Gap.html" title="Possible interior diameter of a surface mesh.">Gap</a> of the surface mesh.  <br /></td></tr>
<tr class="separator:a21900d33c96ef8392057e91bb8bfae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836366bb246c4df2f57420c9494978a3" id="r_a836366bb246c4df2f57420c9494978a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshHexer_1_1VolumeMesh.html">VolumeMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a836366bb246c4df2f57420c9494978a3">fbm_mesh</a> (std::uint64_t levels)</td></tr>
<tr class="memdesc:a836366bb246c4df2f57420c9494978a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a non-fitted volume mesh for this surface mesh.  <br /></td></tr>
<tr class="separator:a836366bb246c4df2f57420c9494978a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ed934d7d4378dfba55f692e5522e64" id="r_a58ed934d7d4378dfba55f692e5522e64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMeshHexer_1_1MeshWarnings.html">MeshWarnings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58ed934d7d4378dfba55f692e5522e64">warnings</a> () const</td></tr>
<tr class="memdesc:a58ed934d7d4378dfba55f692e5522e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create warnings for this surface mesh.  <br /></td></tr>
<tr class="separator:a58ed934d7d4378dfba55f692e5522e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e40606bea8defe6ac57883f605d8c6" id="r_a70e40606bea8defe6ac57883f605d8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshHexer_1_1Result.html">Result</a>&lt; void, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70e40606bea8defe6ac57883f605d8c6">write_to_file</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a70e40606bea8defe6ac57883f605d8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the surface mesh to disk.  <br /></td></tr>
<tr class="separator:a70e40606bea8defe6ac57883f605d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>MeshHexer surface mesh class. </p>
<p>Main API-entry-point for MeshHexer. Contains a triangulated surface and can be used to either calculate properties of the surface mesh or create volume meshes from the surface (non-aligned meshes only, for now).</p>
<p>To create a <a class="el" href="classMeshHexer_1_1SurfaceMesh.html" title="MeshHexer surface mesh class.">SurfaceMesh</a> instance, load a triangle mesh from disk using the MeshHexer::load_from_file() method. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6f4854cbd791971299824961fbc9bf06" name="a6f4854cbd791971299824961fbc9bf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4854cbd791971299824961fbc9bf06">&#9670;&#160;</a></span>bounding_box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMeshHexer_1_1BoundingBox.html">BoundingBox</a> MeshHexer::SurfaceMesh::bounding_box </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Axis-aligned bounding box of the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>The axis-aligned bounding box of the mesh </dd></dl>

</div>
</div>
<a id="a836366bb246c4df2f57420c9494978a3" name="a836366bb246c4df2f57420c9494978a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836366bb246c4df2f57420c9494978a3">&#9670;&#160;</a></span>fbm_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshHexer_1_1VolumeMesh.html">VolumeMesh</a> MeshHexer::SurfaceMesh::fbm_mesh </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>levels</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a non-fitted volume mesh for this surface mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">levels</td><td>Number of regular refinements in intended multi-grid hierarchy</td></tr>
  </table>
  </dd>
</dl>
<p>The volume mesh is created such that after the adaptive refinement prescribed by the volume mesh and after <code>levels</code> further global refinement steps, the final volume mesh roughly hits the local min gap of the surface mesh.</p>
<p>Assumes that adaptive refinements are 3-refinements and global refinements are 2-refinements. </p>

</div>
</div>
<a id="a6feaca6ee9fc384afe3a71d597580d38" name="a6feaca6ee9fc384afe3a71d597580d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6feaca6ee9fc384afe3a71d597580d38">&#9670;&#160;</a></span>gaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structMeshHexer_1_1Gap.html">Gap</a> &gt; MeshHexer::SurfaceMesh::gaps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute <a class="el" href="structMeshHexer_1_1Gap.html" title="Possible interior diameter of a surface mesh.">Gap</a> candidates of the surface mesh. </p>
<p>Gaps try to capture the diameter of the volume described by the surface mesh. The diameter is measured from the barycentric centers of all faces of the surface mesh. For each face of the surface mesh the largest sphere that just touches the center of the face and one other point of the surface mesh is computed. We call this sphere the maximal inscribed sphere (MIS) and use the diameter of that sphere as the diameter at that face.</p>
<pre class="fragment">* │                 │
* │     ∙∙∙∙∙∙∙     │
* │  ∙∙∙       ∙∙∙  │
* │ ∙             ∙ │
* │∙    Diameter   ∙│
* │∙---------------∙│
* │∙               ∙│
* │ ∙             ∙ │
* │  ∙∙∙       ∙∙∙  │
* │     ∙∙∙∙∙∙∙     │
* │                 │
* </pre><p>Note that not all these MIS span gaps that correspond to the intuitive diameter of the surface mesh at that point. Badly reconstructed meshes for example might contain many small "valleys" on surfaces that are supposed to be "smooth"</p>
<pre class="fragment">*              ∙∙∙∙∙∙∙
*            ∙∙       ∙∙
*\         ∙           ∙         /
*  \\      ∙             ∙      //
*    \\    ∙             ∙    //
*      \\  ∙             ∙  //
*        \\ ∙           ∙ //
*          \\∙∙       ∙∙//
*            \\∙∙∙∙∙∙∙//
*              \\   //
*                \ /
* </pre><p>Each gap is given a confidence score in the range [0, 1] that shows how likely that gap corresponds to a real diameter. That score is determined from:</p><ul>
<li>the aspect ratios of involved faces</li>
<li>self-intersections of the surface mesh</li>
<li>relative sizes of involved faces</li>
<li>similarity of normals at the touching points of the MIS</li>
<li>topological distance (distance across the surface between the touching points of the MIS)</li>
<li>dihedral angles near the touching points of the MIS</li>
</ul>
<p>Generally gaps with a score above 0.95 have a good change of corresponding to real diameters.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector containing one gap candiate for each face of the surface mesh </dd></dl>

</div>
</div>
<a id="ae397e5dcc71101bf3e659b137b402391" name="ae397e5dcc71101bf3e659b137b402391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae397e5dcc71101bf3e659b137b402391">&#9670;&#160;</a></span>is_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshHexer::SurfaceMesh::is_closed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the surface mesh describes a closed surface. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if there are no border edges in the surface mesh </dd></dl>

</div>
</div>
<a id="a70f0e732d9e29c57f11de43f7aff1c7b" name="a70f0e732d9e29c57f11de43f7aff1c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f0e732d9e29c57f11de43f7aff1c7b">&#9670;&#160;</a></span>is_outward_oriented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshHexer::SurfaceMesh::is_outward_oriented </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the surface normals of all faces of the surface mesh point towards the unbounded side. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The surface mesh is closed, call <a class="el" href="#ae397e5dcc71101bf3e659b137b402391" title="Check if the surface mesh describes a closed surface.">SurfaceMesh::is_closed()</a> to check </dd>
<dd>
The surface mesh is wound consistently, call <a class="el" href="#a79c153e5973b1205608c450615894834" title="Check if the winding order of the faces of the surface mesh is consistent.">SurfaceMesh::is_wound_consistently()</a> to check</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True, if the surface normals of all faces of the surface mesh point towards the unbounded side, i.e. outside. </dd></dl>

</div>
</div>
<a id="a79c153e5973b1205608c450615894834" name="a79c153e5973b1205608c450615894834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c153e5973b1205608c450615894834">&#9670;&#160;</a></span>is_wound_consistently()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshHexer::SurfaceMesh::is_wound_consistently </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the winding order of the faces of the surface mesh is consistent. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if either all faces of the surface mesh are wound clockwise or all faces of the surface mesh are wound counter-clockwise </dd></dl>

</div>
</div>
<a id="acef6379c61b78d97e3f9e9974ec6fa90" name="acef6379c61b78d97e3f9e9974ec6fa90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef6379c61b78d97e3f9e9974ec6fa90">&#9670;&#160;</a></span>maximal_aspect_ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MeshHexer::SurfaceMesh::maximal_aspect_ratio </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the largest aspect ratio of any face of the surface mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum aspect ratio of any face of the surface mesh </dd></dl>

</div>
</div>
<a id="a21900d33c96ef8392057e91bb8bfae93" name="a21900d33c96ef8392057e91bb8bfae93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21900d33c96ef8392057e91bb8bfae93">&#9670;&#160;</a></span>min_gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMeshHexer_1_1Gap.html">Gap</a> MeshHexer::SurfaceMesh::min_gap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the smallest <a class="el" href="structMeshHexer_1_1Gap.html" title="Possible interior diameter of a surface mesh.">Gap</a> of the surface mesh. </p>
<p>See <a class="el" href="#a6feaca6ee9fc384afe3a71d597580d38" title="Compute Gap candidates of the surface mesh.">SurfaceMesh::gaps()</a> for details on how gaps area measured and scored.</p>
<dl class="section return"><dt>Returns</dt><dd>The smallest gap, by diameter, of all gaps with a score above 0.95, or the smallest gap among the top 10 percent of all gaps, if no such gaps exist. </dd></dl>

</div>
</div>
<a id="a419aa808cbfc07cb147f122aec2255e5" name="a419aa808cbfc07cb147f122aec2255e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419aa808cbfc07cb147f122aec2255e5">&#9670;&#160;</a></span>minimal_aspect_ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MeshHexer::SurfaceMesh::minimal_aspect_ratio </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the smallest aspect ratio of any face of the surface mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimal aspect ratio of any face of the surface mesh </dd></dl>

</div>
</div>
<a id="a58ed934d7d4378dfba55f692e5522e64" name="a58ed934d7d4378dfba55f692e5522e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ed934d7d4378dfba55f692e5522e64">&#9670;&#160;</a></span>warnings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMeshHexer_1_1MeshWarnings.html">MeshWarnings</a> MeshHexer::SurfaceMesh::warnings </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create warnings for this surface mesh. </p>
<p>Warns about:</p><ul>
<li>self-intersections,</li>
<li>degenerate triangles,</li>
<li>highly anisotropic triangles,</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Lists of warnings, separated by types </dd></dl>

</div>
</div>
<a id="a70e40606bea8defe6ac57883f605d8c6" name="a70e40606bea8defe6ac57883f605d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e40606bea8defe6ac57883f605d8c6">&#9670;&#160;</a></span>write_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshHexer_1_1Result.html">Result</a>&lt; void, std::string &gt; MeshHexer::SurfaceMesh::write_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the surface mesh to disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to write to. Must end in .ply</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the surface mesh to disk as a .ply file. The written file contains mesh properties that have been calculated as intermediate results, such as maximal inscribed spheres, or topological distances. These properties will be reused if the written mesh is read again.</p>
<dl class="section return"><dt>Returns</dt><dd>A result indicating success or containing an error message </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="meshhexer_8hpp_source.html">meshhexer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>MeshHexer</b></li><li class="navelem"><a class="el" href="classMeshHexer_1_1SurfaceMesh.html">SurfaceMesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
